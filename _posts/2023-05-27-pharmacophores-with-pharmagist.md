---
layout: post
title:  "Pharmacophore extraction with PharmaGist"
author: Sowmya Krishnan
---
Welcome to my first blog! For the past few years, I have been working on development of deep learning models for accelerating drug design. One of the recent models we developed requires only the structure of the target protein and its active site as inputs (Check out [this paper](https://pubs.acs.org/doi/10.1021/acs.jcim.1c01319) for more details). To validate the molecules generated by this model, we first used the standard approach wherein, we compared the ECFP4 fingerprints of the generated molecules with existing inhibitors using the Tanimoto coefficient to measure molecular similarity. However, we found that a significant proportion (over 90%) of the molecules generated did not have much similarity in terms of the functional groups present in existing actives. So we wanted to understand if the key interacting elements ([Pharmacophores](https://en.wikipedia.org/wiki/Pharmacophore)) of the molecule have any match to that of the already existing inhibitors of the target protein (_i.e._ a different set of functional groups which can achieve the same stereo-electronic effect). We thought this would give us a fighting chance at proving that our model learns the active site features and adds functional groups to the molecule accordingly to achieve good binding. Arguably there might be several other better approaches to do this (anything other than molecular docking), but we chose this approach after much consideration.

So now we had the following information:
* Receptor structure
* Active site
* A small set (<1000) of known inhibitors for the chosen receptor
* A large set (>10,000) generated small molecules specific to the active site

Pharmacophores are primarily of 2 types: Receptor-based and Ligand-based. [PharmaGist](http://bioinfo3d.cs.tau.ac.il/pharma/about.html) is a ligand-based pharmacophore extraction program, which can be handy to do both extraction and screening based on the identified pharmacophores. So we chose to extract the pharmacophores from the set of known inhibitors, and use representative pharmacophores to screen the generated molecules and identify the proportion of “pharmacophore hits”.

Another good thing about PharmaGist is that, it is available as a [stand-alone](http://bioinfo3d.cs.tau.ac.il/cgi-bin/pdownload/progdownload.pl/?pname=PharmaGist) too! That was perfect to run batch calculations for screening the large set of generated molecules we had in hand. After downloading PharmaGist, no installation was required and the pre-compiled binary along with the default configuration files were used for the model validation. This blog will document the exact steps used to extract pharmacophores and screen a library of molecules with that.

# Step 1: Molecule library preparation

To input molecules to PharmaGist, they must be in the .mol2 file format. Since our generative models were RNN-based, the output was in [SMILES](https://www.daylight.com/dayhtml/doc/theory/theory.smiles.html) (Simplified Molecular Input Line Entry System) format, hence needing conversion. We used [OpenBabel](https://openbabel.org/docs/dev/Command-line_tools/babel.html) to do this with a simple command:

```
obabel -ismi input.smi -omol2 -O output.mol2 –gen3d -h
```

This command is for a single SMILES (1D) -> .mol2 (3D) conversion (with explicit hydrogens). The [RDKit](https://www.rdkit.org/) library can also be used to do this with a simple code snippet like this one:

```
rdkitmol = Chem.MolFromSmiles(smiles)
mol2 = Chem.AddHs(rdkitmol)
AllChem.EmbedMolecule(mol2, randomSeed=0xf00d)  #Random seed is for reproducibility
AllChem.MMFFOptimizeMolecule(mol2)
fname = "output.mol"  #Note: Output is in .mol format, not .mol2
print(Chem.MolToMolBlock(mol2), file=open(fname,'w+'))
```

After this is done, the output should be converted from .mol to .mol2 using OpenBabel (```-imol``` and ```-omol2``` flags). To automate this for an entire library of molecules, we used a shell script or a loop construct for OpenBabel and RDKit, respectively. Now that the input is ready, lets move on!

# Step 2: Pharmacophore extraction

For the set of known inhibitors against the chosen receptor or target protein, the top “n” pharmacophores can be extracted using the following command:

```
pharmagist64.linux -c pharmagist.config -f input.txt -i -o ./Output_pharmacophores/
```

Let me break this down for you:
* pharmagist64.linux – name of the pre-compiled binary executable file
* pharmagist.config – default config file which comes with PharmaGist stand-alone version
* input.txt – A text file containing the names of the .mol2 files (along with the path to where they are located) of the input molecules
* Output_pharmacophores – Name of the output directory to write the extracted pharmacophores and alignment files

PharmaGist will align every pair of molecules in the input list such that, their pharmacophore elements match to the maximum extent possible. We used crystal conformations of the known inhibitors (wherever available in holo form) and used the best docking conformations (from [smina](https://github.com/mwojcikowski/smina)) for the rest of the molecules. The final output will be .pha files containing the pharmacophore pivot molecule information, .mol2 files containing the molecular pair alignment coordinates, and .html files to visualize the aligned pairs (enable Javascript in your browser to try this). 

The important post-processing to be done here is to check how many molecules from the input share a pharmacophore identified. We chose top two pharmacophores which cover at least 90% of the molecules in the input list for screening the generated molecules from our deep learning model. Sometimes it happens that there are several distinct classes or series of molecules against the target protein, which demand different pharmacophore arrangements for their accurate description. In such cases, using multiple pharmacophores will help accommodate the inhibitor diversity better (will also increase the chances of finding more molecules from generated set with better match to the pharmacophores identified).

# Step 3: Pharmacophore-based screening of a library of generated molecules

Based on the pharmacophore(s) identified in the previous step, we can screen any number of molecules and obtain the overlap score from PharmaGist. For that, it is better to split the library to be screened into batches of 500 molecules (multi-molecule files in .mol2 format). The main reasons for this are as follows:

* PharmaGist does not follow the molecule ID or numbering defined by the user in the .mol2 file. It uses sequential numbering of molecules in a file for which a _mapping_ will be necessary between the PharmaGist numbering and user-defined molecule identifiers.
* PharmaGist cannot process molecules which contain **boron atoms (B)** since it is not part of the atom type definition in the default config file. So it is best to eliminate molecules with B atoms as a pre-processing step, before batching the molecules.
* Other errors in the middle of screening can also be debugged easily if the library is batched. Otherwise mapping the error to the molecule will be a tedious task (also easier to perform parallel calculations).

Screening command
```
./pharmagist64.linux -c pharmagist.config -p ./Output_pharmacophores/1.pha -i -o ./Screening_results/ -d ./Batch_X.mol2
```

The output from the PharmaGist screening is composed of six scores and the first score can be considered as the overlap score between the chosen pharmacophore and the screened molecule. Sorting based on the overlap score and using a threshold to define “hits” from the screening was our strategy to identify the proportion of generated molecules with pharmacophore-level match to existing inhibitors. By combining screening results from multiple pharmacophores, we could see that 90% of generated molecules could match at least one of the pharmacophores, thereby validating our model.

# Gallery

![Img 1]("./_images/PGist_config_1.png?raw=true")

![Img 2]("./_images/PGist_config_2.png?raw=true")

![Img 3]("./_images/Sample_pha_file.png?raw=true")

![Img 4]("./_images/4pha_image_v1.png?raw=true")

![Img 5]("./_images/Sample_output_PGist.png?raw=true")
